# 6.26
统一使用vscode进行开发，初步定为组长创建新建项目再把其他组员加入协作者，初步定下来做类似C语言的编译，先做一个简单的语言将各个部分的功能模块串通起来之后再对文法进行完善

第一代文法中包含的内容：
变量定义 整形 字符型 字符串型
*函数定义和调用
表达式 算术表达式 赋值表达式 逻辑表达式
if+while+goto+label

初步分工：刘文兴 蒙龙：文法设计+语法分析+语义分析+中间代码生成，其中文法设计 ：文法+翻译文法，张翰韬 钟洁：词法分析+优化+目标代码生成

# 6.29
今天是第一次上机，我们重新进行了一次分工，现在的分工情况是我和钟洁同学负责后端，包括优化和目标代码生成的部分，目标代码使用汇编语义进行。前端部分由张翰韬和刘文兴两位同学负责，包括词法分析，语法分析和语义分析。文法主要是我和张翰韬负责设计。

今天经过语言讨论我们初步确定了文法的设计，文法中的第一代的内容里面暂时先没有了函数的定义和调用，只有main的，也去掉了goto和label。原本是将文法的各个部分分给每个同学来做的，但是张翰韬同学似乎一下子就写出来了。

晚上我们进行了词法分析的和符号表的讨论和初步的开发工作，主要是由张翰韬同学来做，在语法分析中调用词法分析的来获得一个一个TOKEN，但是现在的做法是先词法分析得到所有的TOKEN，放在一个vector里面，然后再一个个地读，如果是每调用一次再读一个TOKEN的方式也可以，但是返回的时候文件流不能关闭，就是源文件的文件流需要在语法分析中打开。但是现在采用的方式虽然是一次性生成完所有的TOKEN，但是也可以一个一个地读。

TOKEN的中包含的内容为一个类型和name，我记得但是课上讲过虽然现在是name但是实际应该是指向符号表中的指针，但是在词法分析时候似乎不能完成完整的符号表，关键字表和界符表可以完成，但是含类型表函数表总表的内容应该是在进行语法分析的时候再来进行确定会方便一点，现在暂定是TOKEN进行初步类别标明为关键字 标识符 界符和常数，但还没完成，等张把代码推上了我们在来一次看

# 6.30
初步完成了文法的设计，我们原本在29号晚上完成了文法的初步设计，但是当时没用留意到有些地方不是LL1的，这个问题我是有责任的，设计文法的时候有一些很明显的错误没有意识到，我们后来就直接开始设计翻译文法，完成了语义动作的插入工作，但是还没有很规范的系统地写出来，但是后来在实际做递归下降子程序的时候发现文法有问题，发现有些地方不是LL1的后来花了挺多时间来更改这一部分，对开发的进度影响还是挺大的。

同时我完成了符号表的设计，在课件的符号表的基础上添加了标识符表，用来语法分析时候判断重复定义以及赋值的时候类型是否统一，但是要注意作用域，和队友商量了之后任务符号表的主要的填写还是在语法分析中进行，在词法分析的时候生成的TOKEN只做简单的分类。符号表的具体填写在做语法分析的时候再来插入会方便很多。

如果之后考虑到函数的定义和调用的话，变量实际上存放的地方应该是在活动记录中，课件上说活动记录是内存单元的一个映射，但是我感觉实际存放在活动记录中也未尝不可，或者说内存中应当由活动记录的结构，活动记录应该是在运行过程中分配，因为不知道会调用多少次，如果一部分事先已经知道了会调用多少次的话就可以提前分配好内存，计算出函数的所有的需要开辟多少的内存空间，但是如果是运行过程中分配的话是不是要在四元式和目标代码生成中生成维护内存的四元式或指令，但是汇编语言并没有动态分配内存的方法，最坏情况下要写一个内存管理的机制。

词法分析基本上完成了，并且也开始了语法分析的工作。

# 7.1
进一步完成了文法设计，完成了LL1的修改而且完成了语义动作的设计，翻译文法完成，目前我的工作主要是完成了翻译文法的设计。同时对之前的符号表进行了修改，在之前的基础上在符号表总表中添加了当前作用域标号，为了语义分析服务添加了符号栈，对象栈，作用域标号栈三个栈，符号栈中存储四元式符号，对象栈中为操作数，但是不仅仅是操作数，过程中各种数值都会存储在对象栈中。也完成了四元式的设计。符号栈，对象栈主要是为了四元式生成服务的，而作用域栈是为了变量重定义以及未定义就是用的时候判断用到，设计方式大概是遇到{分配作用域标号+1并压栈}作用域栈弹栈。语义动作中不仅仅是生成四元式，其实很大的一部分工作是用来维护符号表以及其他的一些工作。反而感觉生成四元式的动作设计思想上是很直来直去的。其他的反而需要一些技巧。

原本我们在设计TOKEN的时候结构是很简单的，仅仅是一个类码一个name，而课上说的是要指向符号表的，而在词法分析的时候难以建立完整的符号表，而当我自己设计语义动作的时候才感觉到这个的必要性，因为在生成四元式的时候，无论是判断是否重定义还是赋值语句判断类型是否吻合，推到中间变量的类型，数组是否越界以及之后目标代码生成的时候找地址等等信息都需要找符号表，所以后来是再一次设计了一个操作数结构体，指向符号表。

在符号表的设计上，在数组的设计中，目前我们是将例如A[1]这样的内容也放到了符号表里面，单独看成是一个变量来操作，不过例如在对数组进行初始化的时候，就会在符号表中生成很大的一块空间，之后看看能不能优化一下。

在设计语义动作的时候我一开始是在if和while语句的推到时候设计四元式的时候也想来一些回填的内容，就是在四元式设计的时候就考虑到跳转到哪一个四元式，不过后来还是弃用了，主要是两个问题，一个是优化的时候如果删除了中间的一部分的话，要维护跳转到那条语句就很麻烦，二则是实际目标代码生成的时候一条四元式可能会生成几条语句，所以回填的工作放在后端还是有它的道理的。

在进行语义动作设计的时候，我才真切的感觉到 四元式 符号表 语义动作 文法 四者是需要高度统一配合的，牵一发动全身。

# 7.2
今天主要是讲我之前写的语义动作的部分和队友们进行了详细的讲解，对符号表中的部分内容进行了进一步的修改，包括将作用域栈从stack改成了vector类型，总表中添加了偏移地址的域，但是偏移地址的域的维护不需要在语义分析的过程中填写，因为当进行优化的时候将一部分的变量删除了之后可能会改变它的偏移地址，添加了长度表，但是现在我们其实并没有自定义的数据类型，所以长度表基本上还用不到。

今天就函数调用时候内存分配问题问了两个老师，活动记录其实是内存中的映射，本身是虚的结构，在实际的内存中不一定严格地按照活动记录的结构来存储，而且严格按照课本上的数据结构维护内存空间是困难的，在某些情况下函数的调用次数是不清晰的，这种情况下就无法提前分配好内存，只能是在运行过程中来进行维护内存或者活动记录，但是汇编语义本身的是没有动态内存分配的说法的，要么是调用系统的api要么是自己写一个内存管理的模块，实际上对于内存管理的这个概念应该是在操作系统之上的范围内才有意义，分配的目的是为了防止别的程序占用，但是对于汇编语言这种低级语言来说不存在占用的这一个说法，因为它可以之间对内存中的单元进行读写，只是这部分内存实际上并不是动态分配的，而是预留出来的。有的时候程序运行时包括，会提示栈溢出，就是指这部分预分配空间不够了。内存管理如果你没有太多动态内存的分配，可以简单写一个。但是这部分想要弄好，还是比较麻烦的。可以考虑先处理一些预定义好类型的变量的存储，动态存储的部分可以作为第二阶段的内容推进。